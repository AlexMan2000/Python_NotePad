#df的创建
import pandas as pd
df=pd.DataFrame({'one':[1,2,3],'two':[4,5,6]},index=['a','b','c'])
     one  two
  a   1    4
  b   2    5
  c   3    6
   
df1=pd.DataFrame(np.array([random.randint(0,3) for i in range(20)]).reshape(4,5),\
index=list('abcd'),columns=list('abcde'))
   a  b  c  d  e
a  2  0  1  1  2
b  1  3  0  0  2
c  1  1  1  1  2
d  3  0  3  3  2
  
  
#返回行索引，返回一个index可遍历对象
df.index


#返回列索引，返回一个index可遍历对象
df.columns


#在原有索引列的基础上改变索引形式
df1.reindex(['a','b'])#相当于取了a,b两个行索引作为索引,相当于取了a,b两行
   a  b  c  d  e
a  1  0  2  2  0
b  1  0  2  2  3


#返回值，多维列表形式
df.values
[[1,8],
 [2,6],
 [3,7],
 [nan,9]].
 
 
#返回df的描述
df.describe()

 
#df的转置
df.T


#df的切片
#访问列
df['one'] #直接访问列是可以的,返回pdSeries
df.one #以属性访问的形式访问one列，返回pdSeries
df[['one']] #返回dataframe
df[['one','two']] #返回多列,df


#访问行
df.loc['a',:]  #返回pdSeries
df.iloc[0,:]  
df.loc[['a','c'],:] #选中多行,df
df.iloc[[0,2],:] #选中多行,df
df.loc[['a','c'],'two']#选中a和c 行，但只有two这一列
df[:3] #行的切片
df.iloc[:3] #行的iloc切片
df.loc['a':'b'] #行的loc切片
df[0] #错误写法
df.iloc[0] #访问第一行，正确写法，返回Series,相当于省略了列的切片


#访问单元格
df['one']['a']  # 先列再行，返回1
df.loc['a','one'] #先行再列，返回1
df.iloc[0,0] #先行再列，返回1
df['one'][0] #混合索引中唯一可行的，返回1


#访问多行和多列
df = pd.DataFrame(np.random.randn(6, 4),
                   index=list(range(0, 12, 2)),
                  columns=list(range(0, 8, 2)))
df
          0         2         4         6
0   0.149748 -0.732339  0.687738  0.176444
2   0.403310 -0.154951  0.301624 -2.179861
4  -1.369849 -0.954208  1.462696 -1.743161
6  -0.826591 -0.345352  1.314232  0.690579
8   0.995761  2.396780  0.014871  3.357427
10 -0.317441 -1.236269  0.896171 -0.487602
df[1:5,2:4] #取除第1-4行，2-3列的一个dataframe
df.iloc[[1,3,5],[1,3]] #原理同上




#行列的交换
df2 = pd.DataFrame(np.random.randn(8, 4),index=dates, columns=['A', 'B', 'T', 'W'])
                A         B         T         W
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

df2.loc[:, ['B', 'A']] = df[['A', 'B']] #错误写法
df2.loc[:, ['B', 'A']] = df[['A', 'B']].to_numpy() #正确写法


#pandas单元格修改
df2[:5]=0 将前五行和列全部修改成0


#布尔索引
df
   A  B  W  T  Y
a  2  0  1  1  2
b  1  3  0  0  2
c  1  1  1  1  2
d  3  0  3  3  2

df.loc['a']>0  #返回pdSeries
out:
A     True
B     False
W     True
T     True
Y     True


df.loc[:,df1.loc['a']>0] """根据布尔判断得到的pdSeries中的True/False情况来选择对应列
这里选择所有a行中数值大于零的单元格所在的列"""


df.sort_values('column',ascending = False,inplace = True)




