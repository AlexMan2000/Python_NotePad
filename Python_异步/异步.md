###  1.1 事件循环

```
#伪代码

任务列表 = [任务1，任务2，任务3,...]

while True:
	可执行的任务列表,已完成的任务列表 = 去任务列表中检查所有的任务,将可执行的和已完成的任务返回
	
	for 就绪任务 in 可执行任务列表:
		执行已就绪任务
		
	for 已完成的任务 in 已完成的任务列表:
		在任务列表中移除已完成的任务
		
	如果任务列表中的任务都已完成，就退出循环
```

```python
import asyncio

#生成一个事件循环列表
loop = asyncio.get_event_loop()



#将所有任务放入任务列表
loop.run_until_complete(任务们)
```

### 1.2 快速上手

协程函数，定义函数时候 `async def 函数名`

协程对象，执行协程函数()得到的协程对象

```python
async def func():
    pass


result = func()
```

注意: 执行协程函数创建协程对象,函数内部代码不会执行

如果想要运行协程函数内部代码，必须要将协程对象交给事件循环来处理。

```python
import asyncio

async def func():
    print("快来搞我吧")

result = func()

#loop = asyncio.get_event_loop()
#loop.run_until_complete(asyncio.wait(result))
asyncio.run(result) #python3.7加入的
```



### 1.3 await

await + 可等待的对象(协程对象，Future对象, Task对象  -> IO等待)

示例1:

```python
import asyncio

async def func():
	print("来玩呀")
    response = await asyncio.sleep(2)
    print("结束",response)
    
asyncio.run(func())
```

示例2:

```python
import asyncio

async def others():
    print("start")
    await asyncio.sleep(2)
    print("end")
    return "返回值"


async def func():
    print("执行协程函数内部代码")
    
    #遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行，当前协程挂起时。 当前协程挂起时，时间循环可以去执行其他协程（任务）。
    response = await others()
    
    print("IO请求结束，结束为：",response)
    
asyncio.run(func())
```

示例3: (一个协程函数内部有多个协程函数对象)

```python
import asyncio

async def others():
    print("start")
    await asyncio.sleep(2)
    print("end")
    return "返回值"


async def func():
    print("执行协程函数内部代码")
    
    #遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行，当前协程挂起时。 当前协程挂起时，时间循环可以去执行其他协程（任务）。
    #但是这里只有一个任务others(),所以只能老老实实等他执行完毕，变成了串行。所以一般用Task对象实现并发。
    response1 = await others()
    print("IO请求结束，结束为：",response1)
    
    
    response2 = await others()
    print("IO请求结束，结束为：",response2)
    
asyncio.run(func())
```

await就是等待对应的值得到结果之后往下走



### 1.4 Task对象

在事件循环中添加多个任务的。

Tasks用于并发调度协程， 通过`asynico.create_task(协程对象`)的方式创建Task)对象,这样可以让协程加入事件循环中等待被调度执行。



示例1:

```python
import asyncio

async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return "返回值"

async def main():
    print("main开始")
    
    #创建Task对象，将当前执行func的函数任务添加到事件循环,并执行任务
    task1 = asyncio.create_task(func())
    
    #创建Task对象，将当前执行func的函数任务添加到事件循环,并执行任务
    task2 = asyncio.create_task(func())
    
    print("main结束")
    
    #当执行某协程遇到IO操作时，自动切换执行其他任务，
    #此处await是等待相对应的协程全部执行完毕并获取结果。
    #执行task1时遇到IO阻塞，立刻切换到事件列表中的其他就绪可执行事件task2,实现并发,类似于异步阻塞
    ret1 = await task1 
    ret2 = await task2
    
    #等到所有结果获取到之后执行print
    print(ret1,ret2)
 
asyncio.run(main())
```



示例2: (标准书写格式)

```python
import asyncio

async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return "返回值"

async def main():
    print("main开始")
	
    #name给task对象起别名，在done中可以获取Task对象名称,立即执行函数
    task_list = [asyncio.create_task(func(),name = 'n1'),
                asyncio.create_task(func(),name = 'n2')]
    print("main结束")
    
    #当执行某协程遇到IO操作时，自动切换执行其他任务，
    #此处await是等待相对应的协程全部执行完毕并获取结果
    done,pending = await asyncio.wait(task_list,timeout = None)
    print(done)
 
#asyncio先创建事件循环，main()主函数内部的asyncio.create_task()把任务加入事件列表
asyncio.run(main())
```

示例3:(tasks写在外面,不常用)

```python
import asyncio

async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return "返回值"

task_list = [func(),
            func()]
    
#asyncio.run会创建事件循环，然后把task_list内部的协程函数对象加入事件循环,才开始执行
#loop = asyncio.get_event_loop()
#loop.run_until_complete(asyncio.wait(task_list))
done,pending = asyncio.run(asyncio.wait(task_list))
print(done)
```



### 1.5 `asyncio.Future`对象

Future是Task的基类, Task对象内部await结果的吹就是基于Future对象实现.

示例1:

```python
async def main():
	#获取当前事件循环
	loop= asyncio.get_event_loop()
    
    
    #创建一个任务(Future对象)，这个任务什么都不干
	fut = loop.create_future()
    
    
    #等待任务最终结果(Future对象)，没有结果则会一直等下去
    await fut
     
asyncio.run(main())
```

示例2: (一般不直接使用)

```python
import 

def def set_after(fut):
    await asyncio.sleep(2)
    fut.set_result("666")
    
    

async def main():
	#获取当前事件循环
	loop= asyncio.get_event_loop()
       
        
    #创建一个任务(Future对象)，这个任务什么都不干,永远不知道什么时候结束
	fut = loop.create_future()
        
        
    #创建一个任务(Future对象),绑定了set_after函数，函数内部在2s之哦户，会给fut赋值，即手动设置future任务的最终结果，那么fut就可以结束了
    await loop.create_task(set_after(fut))
    
    
    #等待Future对象获取最终结果，否则一直等待下去
    data = await fut
    print(data)
 
asyncio.run(main())
```



### 1.6 `concurrent.futures.Future`对象

使用线程池，进程池实现一步操作用到的对象

```python
import time
from concurrent.futures import Future
from concurrent.futures.thread import ThreadPoolExecutor
from concurrent.futures.process import ProcessPoolExecutor

def func(value):
	time.sleep(1)
    print(value)
    return 123
    
    #创建线程池
    pool = ThreadPoolExecutor(5)
    
    #创建进程池
    pool = ProcessPoolExecutor(5)
    
    
    for i in range(10):
        fut = pool.submit(func,i)
        print(fut) #只会执行到print(value),需要通过ret.result()来获取返回值,但此时就会变成同步阻塞的状态
```

以后写代码可能会交叉使用。例如: `crm`项目80%都是基于协程异步编程+MySQL(不支持协程，就得用线程或者进程实现异步)

示例1:(基于协程的异步和基于进程/线程的异步结合使用)

```python
import time
import asyncio
import concurrent.futures

#注意：这里是一个普通函数
def func1():
	#某个耗时操作
	time.sleep(2)
    return "SB"

async def main():
    #创建事件循环
    loop = asyncio.get_running_loop()
    
    #1.第一步：内部会先调用ThreadPoolExecutor的submit方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象
    #第二步： 调用asyncio.wrap_future将concurrent.futures.Future对象包装成为asyncio.Future对象,因为concurrent.futures.Future对象不支持await语法，所以要包装为asyncio.Future对象才能使用
    fut = loop.run_in_executor(None,func1)
    result = await fut
    print("default thread pool",result)
    
    #with concurrent.futures.ThreadPoolExecutor() as pool:
        #result = await loop.run_in_executor(pool,func1)
        #print('custom thread pool',result)
        
    #with concurrent.futures.ProcessPoolExecutor() as pool:
        #result = await loop.run_in_executor(pool,func1)
        #print('custom thread pool',result)
    
asyncio.run(main())
```

案例:普通方法爬虫(无异步)

```python
import requests


def download_image(url):
    #发送网络请求
    print("开始下载")
    response = requests.get(url)
    
    #图片保存到本地文件
    file_name = url.rsplit('_')[-1]
    with open(file_name,mode = 'wb') as file_object:
		file_object.write(response.content)
        
if __name__ == "__main__":
    url_list = ['url1','url2','url3']
    
    for item in url_list:
        download(item)
```

案例: `async` + 不支持异步的模块

```python
import asyncio
import requests


async def download_image(url):
    #发送网络请求
    print("开始下载",url)
    
    loop = asyncio.get_event_loop()
    
    #requests模块默认不支持异步操作，所以就用线程池来配合
    #传入需要包装的函数requests.get
    future = loop.run_in_executor(None,requests.get,url)
    
    response = await future
    print("下载完成")
    
    #图片保存到本地文件
    file_name = url.rsplit('_')[-1]
    with open(file_name,mode = 'wb') as file_object:
		file_object.write(response.content)
        
if __name__ == "__main__":
    url_list = ['url1','url2','url3']
    
    tasks = [download_image(url) for url in url_list]
    
    loop = asyncio.get_event_loop()
	loop.run_until_complete(asyncio.await(tasks))
```



### 1.7 异步迭代器

什么是异步迭代器，是实现了`__aiter__`和`__anext__`方法的对象，`__anext__`必须返回一个`awaitable`对象, `async for `会处理异步迭代器的`__anext__`方法所返回的可等待对象, 直到其引发一个`AtopAsyncIteration`异常

##### 什么是异步可迭代对象?

可在`async for` 语句中被使用的对象，必须通过它的`__alter__()`方法返回一个`asychronous iterator`

```python
import asyncio


class Reader(object):
    def __init__(self):
        self.count = 0

    async def readline(self):
        #await asyncio.sleep(1)
        self.count += 1
        if self.count == 100:
            return None
        return self.count

    def __aiter__(self):
        return self

    async def __anext__(self):
        val = await self.readline()
        if val == None:
            raise StopAsyncIteration
        return val

async def func():
    obj = Reader()
    async for item in obj:
        print(item)

asyncio.run(func())
```



### 1.8 异步上下文管理

此种对象通过定义`__aenter__`和`__aexit__`方法来对`async with`语句中的环境进行控制

```python
import asyncio


class AsyncContectManager:
    def __init__(self,conn):
        self.conn = conn

    async def do_something(self):
        #异步操作数据库
        return 999

    async def __aenter__(self):
        #异步连接数据库
        self.conn = await asyncio.sleep(1)
        return self

    async def __aexit__(self):
        #异步关闭数据库连接
        await asyncio.sleep(1)

async def func():
    #一般有涉及到上下文管理（数据库连接），内部一般都是这样实现的
    async with AsyncContectManager('数据库连接') as f:
        result = await f.do_something()
        print(result)

asyncio.run(func())
```



### 1.9 `uvloop`

是`asyncio`的时间循环的替代方案，事件循环>默认`asyncio`的时间循环

```
pip install uvloop
```

```python
import asyncio
import uvloop
asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())


#编写asyncio的代码


#N诶不的事件循环会自动化为nvloop
asyncio.run(...)
```



### 2.1 异步操作`Redis`数据库

在使用python代码操作时，链接、操作、断开都是网络IO

```python
pip install aioredis
```

案例1:

```python
import asyncio
import aioredis

async def execute(address,password):
    print("开始执行",address)
    #网络IO操作：创建redis连接
    redis = await aioredis.create_redis(address,password=password)

    #网络IO操作: 在redis中设置哈希值car,内部再设置三个键值对，即; redis =
    #{car:{key1:1,key2:2,key3:3}}
    await redis.hmset_dict('car',key1 = 1,key2 = 2,key3 = 3)

    #网络IO操作: 去redis中获取值
    result = await redis.hgetall('car',encoding = 'utf-8')
    print(result)
    
    
    redis.close()
    # 网络IO操作: 关闭redis链接
    await redis.wait_closed()

    print("结束",address)

asyncio.run(execute("redis://47.93.4.198:6379",'root1234'))

```

案例2:

```python
import asyncio
import aioredis

async def execute(address,password):
    print("开始执行",address)
    #网络IO操作：创建redis连接
    redis = await aioredis.create_redis(address,password=password)

    #网络IO操作: 在redis中设置哈希值car,内部再设置三个键值对，即; redis =
    #{car:{key1:1,key2:2,key3:3}}
    await redis.hmset_dict('car',key1 = 1,key2 = 2,key3 = 3)

    #网络IO操作: 去redis中获取值
    result = await redis.hgetall('car',encoding = 'utf-8')
    print(result)
    
    
    redis.close()
    # 网络IO操作: 关闭redis链接
    await redis.wait_closed()

    print("结束",address)
    
#不在list中创建Task的原因是因为事件循环还没有启动
task_list =[
    execute("redis://47.93.4.198:6379",'root1234'),
    execute("redis://47.93.4.198:6379",'root1234')
]

asyncio.run(asyncio.wait(execute("redis://47.93.4.198:6379",'root1234'))

```





### 2.2 异步操作MySQL数据库

```python
pip install aiomysql
```

示例1:(单任务)

```python
import asyncio
import aiomysql


async def execute():
    #网络IO操作:连接MySQL
    conn = await aiomysql.connect(host = '127.0.0.1',port = 3306,user = 'root',pasword='123456',db='mysql')

    #网路IO操作，创建CURSOR
    cur = await conn.cursor()
    
    #网络IO操作: 执行SQL
    await cur.execute("SELECT HOST,USER FROM user")

    #网络IO操作:获取SQL结果
    result = await cur.fetchall()
    print(result)

    # 网络IO操作:关闭链接
    await cur.close()
    conn.close()


asyncio.run(execute())
```

示例2:(多任务)

```python
import asyncio
import aiomysql


async def execute():
    #网络IO操作:连接MySQL
    conn = await aiomysql.connect(host = '127.0.0.1',port = 3306,user = 'root',pasword='123456',db='mysql')

    #网路IO操作，创建CURSOR
    cur = await conn.cursor()
    
    #网络IO操作: 执行SQL
    await cur.execute("SELECT HOST,USER FROM user")

    #网络IO操作:获取SQL结果
    result = await cur.fetchall()
    print(result)

    # 网络IO操作:关闭链接
    await cur.close()
    conn.close()

#多任务连接,体现异步的优势
task_list = [
	execute('47.93.41.197','root!1234'),
	execute('47.93.40.197','root!3451')
]
asyncio.run(asyncio.wait(execute())
```





### 2.3 `FastAPI`框架

```
pip install fastapi
```

```python
pip install uvicorn(asgi内部基于uvloop)
```





### 2.4异步爬虫

```
pip install aiohttp
```

```python
import aiohttp
import asyncio


async def fetch(session,url):
    print("发送请求",url)
    async with session.get(url,verify_ssl = False) as response:
        text = await response.text()
        print("得到结果",url,len(text))
        return text

async def main():
    async with aiohttp.ClientSession() as session:
        url_list = [
            'url1',
            'url2',
            'url3',
        ]

        tasks = [asyncio.create_task(fetch(session,url)) for url in url_list]
        done,pending = await asyncio.wait(tasks)

if __name__ == '__main__':
    asyncio.run(main())
```

