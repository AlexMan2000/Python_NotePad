# Data-Join

![](C:\Users\DELL\Desktop\Python Work\Python Notepad\Python_数据可视化\data-join原理.png)

## 示例

fruitBowl.js

```javascript
import { scaleOrdinal} from 'd3';

const colorScale = scaleOrdinal().domain(['apple','lemon','banana']).range(['darkred','green','yellow'])
const raduisScale = scaleOrdinal().domain(['apple','lemon','banana']).range([50,30])

//{fruits,height}类似于python的**kwargs,用于对象的自动解包
export const fruitBowl = (selection,props) => {
	const {fruits,height} = props;
	const circles = selection.selectAll('circle').data(fruits)
  
  circles.enter()
	.append('circle')
      .attr('cx',(d,i)=>i*120 + 60)
      .attr('cy',height/2)
      .attr('r',0)
	.merge(circles)
      .attr('fill',d=>colorScale(d.type))
  	.transition()
  		.duration(1000)
	.attr('r',d=>raduisScale(d.type));
  
  circles.exit()
      .transition()
      	.duration(1000)
      	.attr('r',0)
      .remove();
}

```

index.js

```javascript
import { select,range,scaleOrdinal} from 'd3';
import { fruitBowl } from './fruitBowl'

const svg = select('svg');

const height = +svg.attr('height'); 
const width = +svg.attr('width');

const makeFruit = type => ({ type }); //返回一个{type:'apple'}对象
let fruits = range(5).map(()=>makeFruit('apple'));//返回五个苹果组成的列表


const render = ()=>{
  console.log({fruits,height})
	fruitBowl(svg,{fruits,height})
}


render();


//Eat an apple
setTimeout(()=>{
fruits.pop();
render()
},1000)


//Replacing an apple with a lamon
setTimeout(()=>{
	fruits[2].type = 'lemon'
	render()
},2000)

//把索引为1的苹果替换成柠檬
setTimeout(()=>{
	fruits = fruits.filter((d,i)=> i !== 1)
	render()
},3000)

//追加一个香蕉
setTimeout(()=>{
	fruits.push({type:'banana'})
	render()
},4000)
```

### 示例解释

​		`data = [apple,apple,apple,apple,apple]`

​		第一次执行的时候,data()处理进来的数据，如果没有设置key的话, 默认根据列表的索引来找绑定的对象。只有enter()会执行。

​		`data = [apple,apple,apple,apple]`

​		第二次更新进来的时候，data()比对更新过的数据, 根据规则执行一样的操作, 发现pop了一个apple, 这时候执行enter()只对那个新增的数据点绑定了图元对象，图元根据其索引绑定对象 ,其他图元不执行绑定操作, 所有图元都不执行merge()操作

​		`data = [apple,apple,lemon,apple]`

​		第三次更新进来data(), 数据中2号索引位置的数据被修改成lemon，但是由于没有设置key, d3会告诉现有的图元根据原来自己绑定的索引去找数据对象, 绑定在0,1,3索引的图元查看数据,发现有数据绑定且与自身的属性相符合没有被修改,不执行enter()和merge()之后的`attr()`。绑定在2号索引的图元查看数据发现有数据绑定，不调用enter(), 但是紧接着发现索引对应的数据与自身的属性不符合了，type从apple变为了lemon，因此调用merge()之后的`attr()`.

​		`data = [apple,lemon,apple]`

​		(重要)第四次更新进来, 原来数据1号索引的元素被删除 ,但是由没有设置key, 所有图元根据自己绑定的索引去取数据

​		第一个DOM图元(apple属性状态，绑定数据的0号索引): 有数据且没有改变, 啥都不干

​		第二个DOM图元(lemon属性状态，绑定数据的1好索引): 有数据但是数据改变, 不调用enter(),调用merge(), 修改自身数据。

​		第三个DOM图元(apple属性状态，绑定数据的2号索引) : 有数据且数据改变, 不调用enter(), 调用merge(), 修改自身数据。

​		第四个DOM图元(apple属性状态，绑定数据的3号索引): 没有数据 ,可调用exit（）删除自身。

### merge()方法

​	d3会通过计算比对得知:会通知所有存在的图元根据用户定义的规则去找自己的数据, 也会根据这些图元得到数据的情况找到那些没有绑定图元的数据点，用于enter()处理。

```javascript
const circles = selection.selectAll('circle').data(fruits)
```

#### 	Enter and Update with Merge

​		有效解决代码冗余

```javascript
circles.enter()
	.append('circle')
	.attr('cx',(d,i)=>i*120 + 60)
	.attr('cy',height/2)
  .merge(circles)
  //将enter和update合并操作,未来要修改的数据放在merge()之后的attr()里面设置
	.attr('fill',d=>colorScale(d.type))
	.attr('r',d=>raduisScale(d.type));
  
  //update只会对已有的要更新的数据做操作
	// circles.attr('fill',d=>colorScale(d.type))
	// .attr('r',d=>raduisScale(d.type));
 
```

#### 	Enter and Update

​		传统写法，产生代码冗余

```javascript
circles.enter()
	.append('circle')
	.attr('cx',(d,i)=>i*120 + 60)
	.attr('cy',height/2)
	.attr('fill',d=>colorScale(d.type))
	.attr('r',d=>raduisScale(d.type));
  
//update只会对已有的要更新的数据做操作
circles.attr('fill',d=>colorScale(d.type))
	   .attr('r',d=>raduisScale(d.type));
 
```

#### 	Exit

```
 circles.exit().remove();
```

### Data-Join数据添加原理

​		 对于那些已经绑定了数据的图元, 未设置key的话会根据索引去数据对象里看看数据是否更新, 有更新就执行merge()之后的`attr()`,没有更新且数据仍然存在就什么都不执行。

​		 对于绑定数据已经移除的图元，只会调用exit()准备删除图元。对于没有绑定图元的数据, 会调用enter(), enter本质上生成指向父节点的指针，而append操作相当于在父节点后添加指针数量的图元并将其与多出的数据绑定, 之后调用merge()之后的`attr()`为新数据初始化绑定图元,append()在主画布中加入这些新的图元,`attr`()们根据映射规则设置图元属性.

### Data-Join中的数据绑定原理

​	在这个例子中，你将会使用D3.js来把数据绑定到简单网页的DOM元素(DOM element)上。

现在开始了！下面是一个简单的HTML网页：

```html
1 <!DOCTYPE html>
2 <html>
3     <head>
4         <script type="text/javascript" src="d3.v3.min.js"></script>
5     </head>
6     <body>
7     </body>
8 </html>
```

打开Chrome的开发者工具进入JavaScript控制台，观察元素查阅器（inspector）。

在JavaScript控制台上输入下面这段代码：

```javascript
var theData = [1,2,3]  //一个数组
var p = d3.select("body").selectAll("p")
     .data(theData)
     .enter()
     .append("p")
     .text("hello");
```

得到这个结果，成功绑定元素!

#### 	<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117154417373.png" alt="image-20210117154417373" style="zoom: 80%;" />



#### D3.js 的 `SelectAll`方法

​		   在上面那段`Javascript`代码中，有一个方法是：.`selectAll`("p").

​       	D3.js中的`selectAll`方法使用的是CSS3中的选择器来获取DOM元素。不同于select方法（该方法获取的是第一个目标元素），而`selectAll`方法选择的是所有匹配的元素。

​			但是！！初识的HTML网页中并不包含<p>，也就是说，该方法返回的是一个空的选择结果（selection）。

​			在此之后呢，我们又使用了`.data(theData)`和.enter()把数据绑定到这个空的选择结果中，这是怎么回事呢？

#### D3.js 的 `data`方法

​		在上面那段`Javascript`代码中，接下来的是.data(`theData`)。

​		这个data操作符是把一个数据数组（可能是数值数组、对象数组或者别的什么数组）与当前的选择结果联系（join）起来。

​		在本例中，并没有提供key值，因此`theData`数组中的每一个元素都被分配到当前选择结果中的一个元素上。数组中第一个元素，也就是数字1，被分配到第一个<p>元素，第二个元素2被分配到相应的第二个<p>，以此类推。

​		但是！！正如上面说过的，初识网页中根本没有一个<p>，那么到底怎么回事？

##### 		D3.js的Virtual Selections

​		与D3.js中的其他方法不同的是，`data`()操作符返回的是三个Virtual selection。

​		这三个virtual selection是***enter,update\***以及***exit\***。

​		**enter**选集：对所有缺失的元素以占位符placeholder替代。

​		**update**选集：包含现有的元素，并绑定到数据

​		剩下的元素最终都会出现在**exit**选集中，并被移除。

​	由于从下面代码得到的选集是空的：

```javascript
	 d3.select("body").selectAll("p")
```

​	因此，虚拟enter选集中包含的是<p>元素的占位符。

我们将会的后面章节继续讨论虚拟选集enter,update,exit，而现在，我们就把焦点放在enter虚拟选集上。

如果想要了解更多虚拟选集(virtual selection)知识，这里推荐一篇经典文章：Mike Bostock 写的"[Thinking with Joins](http://bost.ocks.org/mike/join/)"。

##### Update ,Enter,Exit的处理方式

​		从data()返回的数据有update, `update.enter(),update.exit()`

```javascript
var dataset = [10, 20, 30];  
var p = d3.select("body").selectAll("p");  
          
        //绑定数据后，分别返回update、enter、exit部分  
        var update = p.data(dataset);  
        var enter = update.enter();  
        var exit = update.exit();  
          
        //1.update部分的处理方法  
        update.text( function(d){ return d; } );  
          
        //2.enter部分的处理方法  
        enter.append("p")  
            .text( function(d){ return d; } );  
          
        //3.exit部分的处理方法  
        exit.remove();  
```



##### 使用data()绑定数据

首先我们来看一下data（）与datum（）的区别：

   data（）与datum（）都只是纯粹地将元素它的值与选择集绑定在了一起，但是如果想要在浏览器上看到文本效果，还需要调用text（）来替换字符串，并展示出来。区别：假设要绑定的数组为[3,6,9]，那么我们希望第一个p元素绑定3，第二个绑定6，第三个绑定9。这种情况就需要使用data()函数，如果使用datum()，则会将数组本身绑定到各元素上，即第一个p元素绑定[3,6,9]，第二个绑定[3,6,9]，第三个也是绑定[3,6,9]，其区别如图1所示：

![image-20210117160702185](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117160702185.png)

绑定数据的代码如下:

```javascript

//定义数组  
var dataset = [3, 6, 9];  
  
//选择body中的p元素  
var p = d3.select("body").selectAll("p");  
  
//绑定数据到选择集  
var update = p.data(dataset);  
  
//输出绑定的结果  
console.log(update);  

```

绑定后在控制台的输出结果如下：

![image-20210117160750836](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117160750836.png)

data()函数返回一个对象，对象里包含update部分和两个函数。一个是enter()函数，返回enter部分，一个是exit()函数，返回exit部分。请看如下代码：

```javascript
var dataset = [3, 6, 9, 12, 15];  

var p = d3.select("body").selectAll("p");  

var update = p.data(dataset);  

console.log(update);  

console.log(update.enter());  

console.log(update.exit());  
```

这段代码中，数组长度为5，元素数量为3，多出两个数组项。其输出结果如图（1）和（2）所示：

![image-20210117160933191](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117160933191.png)
图（1）

![image-20210117160941930](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117160941930.png)

图（2）

可以看到enter部分中，D3已经为多余的数组项12和15预留了位置，用于将来的操作。enter部分中还有一个update变量，指向update部分。本次绑定中，没有多余的元素，所以exit中没有内容。如果将数组换成：

```javascript
var dataset = [3];  
```

则exit部分的输出结果如图（3）所示，可以看到多出的两个p元素。

![image-20210117160958301](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117160958301.png)

图（3）

data()函数是按照索引号依次绑定数组各项的。第0个元素绑定数组的第0项，第1个元素绑定数组的第1项，依此类推。也可以不按照此顺序进行绑定，这就要用到data()的第二个参数。这个参数是一个函数，称为键函数（key function）：

```html
<body>  
<!-- 三个空的p元素 -->  
        <p></p>  
        <p></p> 
        <p></p> 
        <script>  
//数据  
  var persons = [ { id: 3 , name:"张三" },  
   { id: 6 , name:"李四" },  
  { id: 9 , name:"王五" }];  


//选择body中的所有的p元素  
 var p = d3.select("body").selectAll("p");  

//绑定数据，并修改p元素的内容  
p.data(persons)  
.text(function(d){  
return d.id + " : " + d.name;  
 });  
</script>  
</body>  
```

结果如下：

3 : 张三 

6 : 李四  

9 : 王五 
下面将persons里的数据更新，再绑定一次数据。本次绑定添加键函数：

```html
<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>选择集与数据绑定</title>
</head>
<body>
	<p></p>
	<p></p>
	<p></p>
<script src=" d3.js"></script>
<script>
    persons = [     { id: 6 , name:"张三" },
 { id: 9 , name:"李四" },
 { id: 3 , name:"王五" }];
var p = d3.select("body").selectAll("p")
p.data(persons, function(d){return d.id })
.text(function(d){
 return d.id + " : " + d.name;
 });</script>
</body>
</html>
```

结果则如下：

1. <p>3 : 王五</p> 

2. <p>6 : 张三</p> 

3. <p>9 : 李四</p> 

可以看到，结果并没有按照新persons数组的次序（6：张三、9：李四、3：王五）排列。绑定过程如图1所示，绑定的顺序不按照索引号绑定，而是使 键 值依次对应。





#### **D3.js的enter方法**

​	D3.js的enter方法获得从data()返回一个虚拟选集。这个方法只能作用于data操作符，因为只有data()返回的是三个虚拟选集。

```
1 var p = d3.select("body").selectAll("p")
2   .data(theData)
3   .enter()
```

​	正如前面所说，对于数组中的数据元素，如果缺少与之对应的DOM元素，那么就会有一个占位符来顶替，而enter方法返回的就是这些占位符集合的引用(reference)。

​	得到这个引用之后，就能对该集合操作了。

​	在这里需要特别注意的是，这个引用后只能链接(chaining)***append，insert***以及***select***操作符，通过他们来操作该引用所指向的集合。

​	在这些操作符链接到.enter()选集，我们就可以像处理其他选集那样，来对其内容进行更改。

#### **D3.js的Append操作符**

​	我们再次来看看这段代码：

```javascript
1 var p = d3.select("body").selectAll("p")
2     .data(theData)
3     .enter()
4     .append("p")
```

​	我们把.append("p")作用于.enter()选集之上。

​	对上一步中enter()所产生的每个占位符（placeholder），都有一个P元素插入进去。

​	由于在我们的数据数组中，有三个数据元素（1,2,3），但是在网页中，没有一个P元素，所以.append("p")就创建并加入了3个段落元素。

​	在本例中，当我们对.enter()的选集使用了append操作符之后，返回的是一个具有3个HTML段落元素的选集。



#### **D3.js的text操作符**

​	如果我们把之前那段`Javascript`代码做一改变，去掉text操作符：

```javascript
1 var theData = [1,2,3]
2 
3 var p = d3.select("body").selectAll("p")
4     .data(theData)
5     .enter()
6     .append("p");
```

我们得到的结果是：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117155601539.png" alt="image-20210117155601539" style="zoom:80%;" />

我们注意到，与之前的那张图片相对比，这里的段落都是不包含任何文字的。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117155625798.png" alt="image-20210117155625798" style="zoom:80%;" />

​	text操作符对所有被选择的元素的`textContent`属性进行赋值。

​	在本例中，.text("hello")，值是“hello”。因为我们的选集中有3个<p>元素，因此每个元素都被插入了“hello”。

 **数据到哪儿去了？**

​	在本文的例子中，一开始就是一个`Javascript`的数据数组：

```
1 var theData = [1,2,3]
```

​	可是到最后，我们得到了三个内容是“hello”的段落。

​	那么对于数字1,2,3，发生了什么？

#### **D3.js的data操作符回顾**

​	让我们通过一个简单的例子，在`javascript`控制台中再次观察下data操作符：

```
1 console.log(d3.select("body"));
```

​	当我们点击回车，然后点击向下的箭头来查看“body”的属性，你看到的应该如下：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117155654820.png" alt="image-20210117155654820" style="zoom:80%;" />

在0:<body>这一行下面，你可以看到HTML中body元素的属性。

现在，我们在`Javascript`控制台运行一下下面这句代码，我们加入了.data()操作符。

```
1 console.log(d3.select("body").data([1]));
```

我们的数据出现在名为_data_的属性中：

![image-20210117155819467](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117155819467.png)

当我们把数据分配到一个元素上时，这个数据被存储到_data_属性中。

到此，数据可以通过_data_属性被再选。这也就是我们所说的数据绑定到Dom元素(Binding Data to Dom Elements)。

#### **初始例子回顾**

回顾我们在页面最上方提到的那个例子，现在我们使用console.log()来查看数据绑定到什么地方了：

```
1 var theData = [1,2,3]
2 
3 var p = d3.select("body").selectAll("p")
4     .data(theData)
5     .enter()
6     .append("p")
7     .text("love")
8 
9 console.log(p);
```

结果是：

![image-20210117155843645](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117155843645.png)

从上图可以看出3个段落元素被添加。

你还会看到最后一个（第三个）段落元素的_data_属性值为3，这个值就是来自我们的数据集`theData`！

#### D3.js的merge()方法

```javascript
const groups = selection.selectAll('g').data(fruits,d=>d.id)
console.log(groups)
console.log(groups.select('circle'))
  
```

得到结果如下（上面是groups,下面是`groups.select('circle')`)

可见，merge()接收一个update对象, 表明要修改的图元对象

![image-20210117163307169](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210117163307169.png)



### 键值关系优化

​	明确图元和数据的一对一映射关系,通过设置key的值

```javascript
index.js
const makeFruit = type => ({ type,id:Math.random() });


fruitBowl.js
export const fruitBowl = (selection,props) => {
	const {fruits,height} = props; //解包
	const circles = selection.selectAll('circle').data(fruits,d=>d.id)
  
  circles.enter()
	.append('circle')
  		.attr('cx',(d,i)=>i*120 + 60)
		.attr('cy',height/2)
  		.attr('r',0)
	.merge(circles)
		.attr('fill',d=>colorScale(d.type))
  	.transition()
  		.duration(1000)
		.attr('r',d=>raduisScale(d.type));
  
  circles.exit().transition().duration(1000).attr('r',0).remove();
}

```

## 动态效果展示

#### 案例1

fruitBowl.js

```javascript
import { scaleOrdinal} from 'd3';

const colorScale = scaleOrdinal().domain(['apple','lemon','banana']).range(['darkred','green','yellow'])
const raduisScale = scaleOrdinal().domain(['apple','lemon','banana']).range([50,30])

const xPosition = (d,i) => i*120+60;
//{fruits}类似于python的**kwargs,用于对象的自动解包
export const fruitBowl = (selection,props) => {
	const {fruits,height} = props;
  
	const circles = selection.selectAll('circle').data(fruits,d=>d.id);
  circles.enter()
	.append('circle')
  		.attr('cx',xPosition)
		.attr('cy',height/2)
  		.attr('r',0)
	.merge(circles)
		.attr('fill',d=>colorScale(d.type))
  	.transition()
  		.attr('cx',xPosition)
  	.duration(1000)
		.attr('r',d=>raduisScale(d.type));
  circles.exit()
      .transition()
      .duration(1000)
      .attr('r',0)
      .remove();
  
// 添置文本动画
  const text = selection.selectAll('text').data(fruits,d=>d.id)
  text.enter()
	.append('text')
  		.attr('x',xPosition)
		.attr('y',height/2+120)
	.merge(text)
  		.attr('x',xPosition)
		.text(d=>d.type)
  text.exit()
      .remove();
}
```

#### 案例2(嵌套关系示例)

​		较难

```javascript
import { scaleOrdinal} from 'd3';

const colorScale = scaleOrdinal().domain(['apple','lemon','banana']).range(['darkred','green','yellow'])
const raduisScale = scaleOrdinal().domain(['apple','lemon','banana']).range([50,30])

const xPosition = (d,i) => i*120+60;
//{fruits}类似于python的**kwargs,用于对象的自动解包
export const fruitBowl = (selection,props) => {
	const {fruits,height} = props;
  
  const bowl = selection.selectAll('rect')
  	.data([null])
  	.enter()
  	.append('rect')
  	.attr('y',110)
  	.attr('width',800)
  	.attr('height',300)
  	.attr('rx',150)
  
  const groups = selection.selectAll('g').data(fruits,d=>d.id)
  //绑定好的函数
  const groupsEnter = groups.enter().append('g');
  console.log(groups)
  
  groupsEnter.merge(groups)
  		.transition()
  		.duration(1000)
  		.attr('transform',(d,i)=>`translate(${i*120+60},${height/2})`)
 	groups.exit().remove();
  

 	groupsEnter.append('circle')
  	.merge(groups.select('circle'))
  	.transition()
  	.duration(1000)
		.attr('r',d=>raduisScale(d.type))
  	.attr('fill',d=>colorScale(d.type));
  
  
  groupsEnter.append('text')
  	.merge(groups.select('text'))
  	.transition()
  		.duration(1000)
		.text(d=>d.type)
  	.attr('y',120)

}
```



